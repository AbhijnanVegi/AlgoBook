# How do QR Codes work ?

**QR code** is short for quick response code is type of two-dimensional barcode. The QR code became popular due to its fast readability and greater storage capacity compared to standard barcodes. A QR code consists of black squares arranged in a square grid on a white background, which can be read by an imaging device. Below is the QR code for a Wikipedia page.

<img src="Assets/image-20211126220036203.png" alt="image-20211126220036203" style="zoom:80%;" />

We will now explore how a QR code is generated and also how its interpreted.

## Encoding of a QR Code

<img src="https://miro.medium.com/max/700/0*tMXCCLjrXSZ4wq-s" alt="img" style="zoom:67%;" />

The above image consists of the breakdown of a QR Code. Position and alignment markings help the scanner identify the QR code. Timing pattern tells the scanner the size of the data matrix. Version specifies the version since multiple of them are in use. Format provides information regarding error tolerance and data mask pattern.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/QR_Character_Placement.svg/280px-QR_Character_Placement.svg.png" alt="img" style="zoom:150%;" />

The above image shows how bytes are encoded in qr code. It starts from bottom right where the encoding is mentioned moving up specifying the length of data encoded and the data following it in a zig zag pattern. The other blocks contain the error correction codes which will be discussed in further section.

## Error correction codes

QR Codes use **Reed-Solomon error correction**, so that they can withstand a higher margin of error during the decoding process. They were introduced by Irving S. Reed and Gustave Solomon. 

### Encoding

Reed-Solomon codes operate on a block of data treated as a set of finite field elements called symbols (In this case its the finite field $\mathbb{F}_{256}$). If the message if size k, the $t = n-k$ symbols are used as check symbols. reed Solomon code can detect but not correct any combination of up to t erroneous symbols, or locate and correct up to $\lfloor t\rfloor$ erroneous symbols.

The message is interpreted as the coefficients of a polynomial $p(x)$. The encoder computes a related polynomial $s(x)$ of degree $n-1$ where $n \leq q-1$ and sends the polynomial $s(x)$. The polynomial $s(x)$ is generated by multiplying the message polynomial of degree $k-1$ with a generator polynomial of degree  $n-k$  that is known to both sender and the receiver. The generator polynomial is defined as the the polynomial whose roots are sequential powers of the field primitive $\alpha$ (In this case $\alpha^8+\alpha^4+\alpha^3+\alpha^2+1=0$). The Reed-Solomon code uses one of 37 different polynomials over $\mathbb{F}_{256}$. The rules for selecting the degree are specific to the QR standard. 

### Decoding

The encoded message is viewed as the coefficients of a polynomial $s(x)$. As a result of the Reed-Solomon encoding procedure, $s(x)$ is divisible by the generator polynomial $g(x)$. Since $s(x)$ is a multiple of $g(x)$, it inherits all its roots.

Let the transmitted polynomial b corrupted in transit by an error polynomial $e(x)$. Thus giving the received polynomial $r(x) = s(x) + e(x)$. The coefficient $e_i$ of $x$ in $e(x)$ is 0 if no error in that power of $x$. The goal of the decoder is to find the number of errors, positions of errors and error values.

This involves multiple steps

1. **Syndrome decoding**
   The decoder starts by evaluating the polynomial as received at points $\alpha^1...\alpha^{n-1}$. We call the results of that evaluation the syndromes, $S_j$. They are defined as
   $$
   S_j = r(\alpha^j) = e(\alpha^j),\ j = 1,2,...,n-k\\
   = \sum_{k=1}^ve_{i_k}(\alpha^j)^{i_k}
   $$
   Thus if all syndromes are zero, the message wasn’t corrupted and the decoder exits.

2. **Error locators and error values**
   Let us define error locators $X_k$ and error values $Y_k$ as
   $$
   X_k = \alpha^{i_k}\\
   Y_k = e_{i_k}
   $$
   The syndromes can be written as
   $$
   S_j = \sum_{k=1}^vY_kX_k^j
   $$
    The syndromes give a system of $n − k ≥ 2ν$ equations in $2ν$ unknowns, but that system of equations is nonlinear in the $X_k$ and does not have an obvious solution. However, if the $X_k$ were known, then the syndrome equations provide a linear system of equations that can easily be solved for the $Y_k$ error values.

   The rest of the algorithm serves to locate the errors, and will require syndrome values up to $2v$, instead of just the $v$ used thus far. This is why twice as many error correcting symbols need to be added as can be corrected without knowing their locations.

3. **Error locator polynomial**
   Define the error locator polynomial $A(x)$ as 
   $$
   A(X) = \prod_{k=1}^v(1-xX_k)
   $$
   The zeros of $A(x)$ are the reciprocals $X_k^{-1}$. That is $A(X_k^{-1}) = 0$. Let $j$ be any integer such that $1\leq j\leq v$. Multiply both sides by $Y_kX_k^{j+v}$. The equation then reduces to
   $$
   S_jA_v+S_{j+1}A_{v-1}+...+S_{j+v-1}A_1 = -S_{j+v}
   $$
   Since $j$ can be any integer between $1$ and $v$, we have $v$ linear equations, which can be solved to give the coefficients of the error locator polynomial, the roots of which give us the error locations. The above calculation above assumes that the decoder knows the number number of errors $v$. The decoder does not determine this value directly instead searches for it by trying successive values.
   
4. **Roots of error locator polynomial**
   We have now fully constructed the error locator polynomial from the coefficients $A_i$ found in the previous step. The roots are calculated using an exhaustive search. The error locators are the reciprocals of these roots. An example of the exhaustive search is Chien search. You can read more about it [here](https://en.wikipedia.org/wiki/Chien_search)

5. **Calculation of error values and locations**
   Once the values of $X_k$ are known, the syndrome equations obtained above can be solved to obtain the values of $Y_k$. $i_k$ can be calculated by $\log_\alpha{X_k}$. This is generally done using a precomputed lookup table.

6. **Fix errors**
   Finally, $e(x)$ is generated from $i_k$ and $e_{i_k}$ and then is subtracted from $r(x)$ to get the originally sent message $s(x)$, with errors corrected

With that we have successfully decoded the QR code and fixed any errors that might have occurred during its scanning

---

- An example of decoding Reed-Solomon code can be found [here](https://ntrs.nasa.gov/api/citations/19900019023/downloads/19900019023.pdf)
- There are other algorithms for decoding Reed-Solomon code which can be found [here](https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Berlekamp%E2%80%93Massey_decoder)
- A code oriented working of the QR code can be found [here](https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders)